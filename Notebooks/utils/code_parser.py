# !pip install pysha3
import sha3
import re

class FileCodeParser():
    def __init__(self, contract_files):
        self.contracts = contract_files
        self.codecontracts = []

        for name in self.contracts:
            bp = CodeParser(self.contracts[name], name)
            self.codecontracts.append(bp)

    def get_codecontracts(self):
        return self.codecontracts

class CodeParser():
    def __init__(self,contract_file,contract_name):
        self.contract_name = contract_name
        self.contract_file = contract_file
        self.funciones = self._extract_function_definitions(self.contract_file)
        self.name_pairs = self._get_encripted_names()

    def _extract_body_code(self,contract_file):
        i = 0
        counter = 0
        at_least_one_entry = False
        while i<len(contract_file):
            if contract_file[i] == '{':
                counter+=1
                at_least_one_entry = True
            elif contract_file[i] == '}':
                counter-=1
            if at_least_one_entry and counter == 0:
                return i
            i+=1
        return i

    def _find_next_function(self,contract_file):
        try:
            desde = contract_file.index('function')
            hasta = contract_file[desde:].index(')') + desde

            function_call = contract_file[desde:hasta + 1]
            file_reminder = contract_file[hasta + 1:]

            hasta = self._extract_body_code(file_reminder)

            function_body = file_reminder[:hasta+1]
            file_reminder = file_reminder[hasta + 1:]
            return function_call, function_body,file_reminder
        except:
            return "", "", contract_file

    def _extract_function_definitions(self,contract_file):
        fn = 'start'
        funciones = []
        c = contract_file
        while fn != "":
            fn, body, c = self._find_next_function(c)
            if fn != '':
                funciones.append([fn,body])
        return funciones

    def _fname_encode_parser(self, fname):
        computing_fsel = {
            'uint ': 'uint256 ',
            'uint[]': 'uint256[]',
            'int ': 'int256 ',
            'int[]': 'int256[]',
            'fixed ': 'fixed128x18 ',
            'ufixed ': 'ufixed128x18 ',
            'fixed[]': 'fixed128x18[]',
            'ufixed[]': 'ufixed128x18[]'
        }
        fname = fname.replace('function()','function noname()')
        data = fname.split("function ")[1].split(')')[0] + ')'
        for key in computing_fsel:
            data = data.replace(key, computing_fsel[key])

        data = re.sub(', *', ',', data)
        data = re.sub('\( *', '(', data)
        data = re.sub(' [^,]*,', ',', data)
        data = re.sub(' [^)]*[)]', ')', data)

        return data
    def _get_encripted_names(self):
        name_pairs = []
        for fname,body in self.funciones:
            fn = self._fname_encode_parser(fname)
            k = sha3.keccak_256()
            k.update(fn.encode('ascii'))
            res = k.hexdigest()[:8]
            name_pairs.append([res, fname,body])
        return name_pairs