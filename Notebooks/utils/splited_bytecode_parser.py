from evmdasm import EvmBytecode

class FileBytecodeParser():
    def __init__(self, contracts):
        self.contracts = contracts
        self.bytecontracts = []
        for name in self.contracts:
            bp = BytecodeParser(self.contracts[name],name)
            self.bytecontracts.append(bp)

    def get_bytecontracts(self):
        return [bc for bc in self.bytecontracts if bc.has_contract]

class BytecodeParser():
    def __init__(self,contract,contract_name):
        self.contract_name = contract_name
        self.contract = contract
        self.body_functions = {}
        self.has_contract = len(contract)!=0

        if len(contract)!=0:
            self._get_bytecode()
            try:
                self._clean_bytecode()
                self._split_bytecode()
            except:
                self.potential_body_fn = [[]]

    def _decodepairwise(self,l):
        salto = 2
        i = 0
        final = []
        while i < len(l):
            elem = int(l[i:i + salto], 16)
            if elem == 0:
                return final
            elem = chr(int(l[i:i + salto], 16))
            final.append(elem)
            i += salto
        return ''.join(final)

    def _parse_instructions(self,instrucciones):
        parser = []
        acum = 0
        for i, instruccion in enumerate(instrucciones):
            parser.append([acum + i, instruccion.name,
                           instruccion.operand, int('0' + instruccion.operand, 16),
                           self._decodepairwise(instruccion.operand)])
            acum += (instruccion.size - 1)
        return parser

    def _remove_creation(self,instrucciones):
        c = 0
        n = len(instrucciones[:-1])
        for i in range(n):
            if instrucciones[i][1] == 'PUSH1' and instrucciones[i][2] == '80':
                if instrucciones[i + 1][1] == 'PUSH1' and instrucciones[i + 1][2] == '40':
                    if c == 1:
                        inst = []
                        dif = instrucciones[i][0]
                        for row in instrucciones[i:]:
                            row[0] -= dif
                            inst.append(row)
                        return inst
                    else:
                        c += 1

        return instrucciones

    def _get_wrappers_location(self,instrucciones):
        # Aca tengo que pararme en el hub (tambien llamado function selector)
        # Voy hasta CALLDATALOAD
        # Cada vez que veo push4, es el hashname de la funcion
        # Sigo avanzando, cada vez que veo "push2"+"JUMPI" es la ubicacion del wraper
        # Cuando veo un revert salgo porque no hay mas funciones
        inside_hub = False
        wrappers_pos = []
        n = len(instrucciones)
        next_name = ''
        for i in range(n - 1):
            if instrucciones[i][1] == 'CALLDATALOAD':
                inside_hub = True
                continue

            if not inside_hub:
                continue

            if instrucciones[i][1] == 'REVERT':
                break

            if instrucciones[i][1] == 'PUSH4':
                next_name = f'{instrucciones[i][2]}'

            if instrucciones[i][1] == 'PUSH2' and instrucciones[i + 1][1] == 'JUMPI':
                jdest = instrucciones[i][3]
                wrappers_pos.append([next_name, jdest])

        return wrappers_pos

    def _inst_pos_to_array_pos(self,instrucciones):
        itoar = {}
        for i, inst in enumerate(instrucciones):
            itoar[inst[0]] = i
        return itoar

    def _check_correct_jumpdest(self,instrucciones):
        for name, pos in self.wrappers_pos:
            inst_dest = instrucciones[self.itoar[pos]][1]
            if inst_dest != 'JUMPDEST':
                print(f"FN:{name} is not JUMPDEST: {inst_dest}")

    def _split_code_by_jumpdest(self,instrucciones):
        potential_body_fn = []
        row = []
        for inst in instrucciones:
            if inst[1] == 'JUMPDEST':
                potential_body_fn.append(row)
                row = []
            row.append(inst)

        if len(row) != 0:
            potential_body_fn.append(row)

        postoarr = {}
        for i, code in enumerate(potential_body_fn[1:]):
            postoarr[code[0][0]] = i

        return potential_body_fn[1:], postoarr

    def _get_body_location(self, name, pos, instrucciones):
        # Aca tengo que pararme en el wrapper
        # Avanzo hasta que me encuentre un push2 + JUMP
        pos = self.itoar[pos]
        n = len(instrucciones)

        for i in range(pos, n - 1):
            if instrucciones[i][1] == 'PUSH2' and instrucciones[i + 1][1] == 'JUMP':
                jdest = instrucciones[i][3]
                return jdest

        print(f'Wrong pos Path {name},{pos}')

    def _remove_metadatahash(self, instrucciones):
        for i in range(len(instrucciones)-1):
            if instrucciones[i][1] == 'LOG1' and instrucciones[i + 1][1] == 'PUSH6':
                return instrucciones[:i]

        print(f'Could not found metadatahash')
        return instrucciones

    def _remove_UNK(self, instrucciones):
        inst_clean = []
        for row in instrucciones:
            if 'UNK' in row[1]:
                continue
            inst_clean.append(row)
        return inst_clean

    def _clean_last_bodyfn(self,instrucciones):
        # Busco donde hay LOG1 + PUSH6 (aca debe terminar el fullbody)
        # Nota: recordemos que al final de un contrato se loggea la metadatahash
        # Aca se arman las url de swarm por eso van a empezar con log1 y despues push de bzz...
        # Finalmente lo que resta es un codigo de swarm muy largo
        # Y los ultimos bits muestran el largo de ese codigo.
        # https://swarm-guide.readthedocs.io/en/latest/?highlight=bzz
        # https://docs.soliditylang.org/en/v0.4.25/metadata.html?highlight=swarm%20hash#encoding-of-the-metadata-hash-in-the-bytecode
        # https://docs.ethswarm.org/docs/introduction/terminology
        return self._remove_UNK(self._remove_metadatahash(instrucciones))


    def _get_bytecode(self):
        ebc = EvmBytecode(self.contract)
        instrucciones = ebc.disassemble()
        #Acomodo los saltos para que sean por bytes
        instrucciones = self._parse_instructions(instrucciones)
        #Borro CREATION code si lo tiene
        self.instrucciones = self._remove_creation(instrucciones)
        
    def _clean_bytecode(self):
        #Ubicacion de los wrappers
        self.wrappers_pos = self._get_wrappers_location(self.instrucciones)
        #Diccionario de ubicaciones
        self.itoar = self._inst_pos_to_array_pos(self.instrucciones)
        #Controlo que sean instrucciones JUMPDEST las ubicaciones de los wrappers
        self._check_correct_jumpdest(self.instrucciones)

        #Busco todos los posibles BodyFns (Son todos los JUMPDEST despues del ultimo wrapper)
        #Esto puede traer por "error" algun jumpdest de alguna variable o algun metodo privado, pero no importa
        #los que tengan hash son los que vamos a terminar quedandonos.

        self.instrucciones_b = self._clean_last_bodyfn(self.instrucciones)
        
    def _split_bytecode(self):
        potential_body_fn,postoarr = self._split_code_by_jumpdest(self.instrucciones_b)
        #print(len(potential_body_fn),len(potential_body_fn_b))

        # Busco las DIR que indica en los wrappers:
        self.body_functions = {}
        for name,pos in self.wrappers_pos:
            jdest = self._get_body_location(name, pos, self.instrucciones)
            jdest = postoarr.get(jdest,-1)
            if jdest == -1:
                print('Error with',name,'JDest not found')
            else:
                self.body_functions[name] = potential_body_fn[jdest]

        self.potential_body_fn = potential_body_fn